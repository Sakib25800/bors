# Development guide
This document should help you make sense of the codebase and provide
guidance on working with it and testing it locally.

Directory structure:
- `migrations`
    - `sqlx` migrations that are the source of truth for database schema
- `src/bors`
    - Bors commands and their handlers.
- `src/database`
    - Database access layer built on top of `sqlx`.
- `src/github`
    - Communication with the GitHub API and definitions of GitHub webhook messages.

## Architecture diagram
The following diagram shows a simplified view on the important state entities of Bors. `bors_process` handles events generated by webhooks. It uses a shared global state through `BorsContext`, which holds a shared connection to the database and a command parser. It also has access to a map of repository state. Each repository state contains an API client for that repository, its loaded config, and permissions loaded from the Team API.

```mermaid
---
title: Important entities
---
flowchart
    BorsContext
    repo_client_1["GithubRepositoryClient"]
    repo_client_2["GithubRepositoryClient"]

    repo_state_1["RepositoryState"]
    repo_state_2["RepositoryState"]

    BorsContext --> repo_state_1 --> repo_client_1 --> repo1
    BorsContext --> repo_state_2 --> repo_client_2 --> repo2

    repo_state_1 --> cr1["Config (repo 1)"]
    repo_state_1 --> pr1["Permissions (repo 1)"]

    repo_state_2 --> cr2["Config (repo 2)"]
    repo_state_2 --> pr2["Permissions (repo 2)"]

    BorsContext --> db[(Database)]

    bors_process --> BorsContext
```

## How to test bors on live repositories
Bors has a `cargo` test suite that you can run locally, but sometimes nothing beats an actual test on live, GitHub
repositories. The bot has a staging deployment at the https://github.com/rust-lang/bors-kindergarten repository,
where you can try it however you want.

Nevertheless, sometimes it might be easier to test it on your own repository. The process is a bit involved, but it
can still be done if needed.

One-time setup:
- Create your own GitHub app.
  - Configure its webhook secret.
  - Configure its private key.
  - Give it permissions for `Actions` (r/w), `Checks` (r/w), `Contents` (r/w), `Issues` (r/w) and `Pull requests` (r/w).
  - Subscribe it to webhook events `Issue comment`, `Pull request`, `Pull request review`, `Pull request review comment` and `Workflow run`.
- Install your GitHub app on some test repository where you want to test bors.
  - Don't forget to configure `rust-bors.toml` in the root of the repository, and also add some example CI workflows.

Everytime you want to run bors:
- Run bors locally.
  - Set `APP_ID` to the ID of the app
  - Set `WEBHOOK_SECRET` to the webhook secret of the app.
  - Set `PRIVATE_KEY` to the private key of the app.
  - (optional) Set `WEB_URL` to the public URL of the website of the app.
  - (optional) Set `CMD_PREFIX` to the command prefix used to control the bot (e.g. `@bors`).
- Set up some globally reachable URL/IP address for your computer, e.g. using [ngrok](https://ngrok.com/).
  - Configure the webhook URL for your app to point to `<address>/github`. You can use [gh webhook](https://docs.github.com/en/webhooks/testing-and-troubleshooting-webhooks/using-the-github-cli-to-forward-webhooks-for-testing) for that.
- Try `@bors ping` on some PR on the test repository :)

## Seeding
For testing the merge queue, there's a `scripts/seed.py` script that can automatically create multiple PRs and approve them with `@bors r+` command.

### Prerequisites
```console
$ pip install PyGithub
```

### Usage
The script requires a GitHub personal access token with the following permissions:
- **Contents** (read/write)
- **Pull requests** (read/write)
- **Issues** (write)

```console
$ python scripts/seed.py --repo owner/repo-name --token $GITHUB_TOKEN --count 5
```

### What it does
1. Creates multiple branches with simple changes (new markdown files)
2. Opens pull requests for each branch
3. Posts `@bors r+` comments to approve each PR

## Database
You must have `sqlx-cli` installed for the following commands to work.
```console
$ cargo install sqlx-cli@0.7.4 --no-default-features --features native-tls,postgres
```

The database can be set up with the docker-compose file in the root of the repository:

```console
$ docker-compose up -d
```

Then, set the `DATABASE_URL` environment variable to the connection string of the database.
The content of the variable is can be found in the `.env.example` file.
If an `.env` file is present, the environment variable listed in it will be picked up automatically by `sqlx`.

```console
$ export DATABASE_URL=postgres://bors:bors@localhost:5432/bors
```

### Running tests
Having the database up and running, with the `DATABASE_URL` set, is required to run the tests.

Make sure to also run `cargo sqlx migrate run` to apply the migrations to the database.

### Updating the DB schema

> [!CAUTION]
> When adding a new `NOT NULL` column, always specify the `DEFAULT` value that will be backfilled
> during the migration! Otherwise, the migration might break the deployed bors service.

1) Generate a new migration
    ```console
    $ cargo sqlx migrate add <new-migration>
    ```
2) Change the migration manually in `migrations/<timestamp>-<new-migration>.sql`.
3) Apply migrations to the **Postgre** DB.
    ```console
    $ cargo sqlx migrate run
    ```
4) Add a test data file to `tests/data/migrations/<timestamp>-<new-migration>.sql`.
    - The file should contain SQL that inserts some reasonable data into a test database after the migration is applied.
    The goal is to check that we have a test database with production-like data, so that we can test that applying migrations will not produce errors on a non-empty database.
    - If it doesn't make sense to add any data to the migration (e.g. if the migration only adds an index), put `-- Empty to satisfy migration tests` into the file.

### Regenerate `.sqlx` directory
```console
$ rm -rf .sqlx
$ cargo sqlx prepare -- --all-targets
$ git add .sqlx
```

After that, you should commit the changes to the `.sqlx` directory.

Make sure to remove the `.sqlx` directory before running the `prepare` command, to ensure that leftover queries are not do not remain committed to the repository.

## Updating commands
When modifying commands, make sure to update both:

1. The help page in `templates/help.html`
2. The `@bors help` command output in `src/bors/handlers/help.rs`

## Logs in tests
By default, logs are disabled in tests. To enable them, add `#[traced_test]`
on top of the test function.

## Faster compilation
Bors has a lot of dependencies and can be fairly slow to compile. If you want to improve compilation speed, you could use a faster linker, e.g. LLD.

To do that, install it (e.g. using `sudo apt install lld`) and then put this:
```toml
[build]
rustflags = ["-C", "link-arg=-fuse-ld=lld"]
```
into `.cargo/config.toml`.
